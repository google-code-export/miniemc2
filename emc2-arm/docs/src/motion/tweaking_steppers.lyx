#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass book
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 1
\paperpagestyle default

\layout Subsection

Getting the most out of Software Stepping
\layout Standard

Generating step pulses in software has one very big advantage - it's free.
 Just about every PC has a parallel port that is capable of outputting step
 pulses that are generated by the software.
 However, software step pulses also have some disadvantages:
\layout Itemize

limited maximum step rate
\layout Itemize

jitter in the generated pulses
\layout Itemize

loads the CPU 
\layout Standard

This chapter has some steps that can help you get the best results from
 software generated steps.
\layout Subsubsection

Run a Latency Test
\layout Standard

Latency is how long it takes the PC to stop what it is doing and respond
 to an external request.
 In our case, the request is the periodic "heartbeat" that serves as a timing
 reference for the step pulses.
 The lower the latency, the faster you can run the heartbeat, and the faster
 and smoother the step pulses will be.
\layout Standard

Latency is far more important than CPU speed.
 A lowly Pentium II that responds to interrupts within 10 microseconds each
 and every time can give better results than the latest and fastest P4 Hyperthre
ading beast.
\layout Standard

The CPU isn't the only factor in determining latency.
 Motherboards, video cards, USB ports, and a number of other things can
 hurt the latency.
 The best way to find out what you are dealing with is to run the RTAI latency
 test.
\layout Quote

DO NOT TRY TO RUN EMC2 WHILE THE TEST IS RUNNING
\layout Standard

On Ubuntu Dapper, you can run the test by opening a shell and doing:
\layout LyX-Code

sudo mkdir /dev/rtf; 
\layout LyX-Code

sudo mknod /dev/rtf/3 c 150 3; 
\layout LyX-Code

sudo mknod /dev/rtf3 c 150 3; 
\layout LyX-Code

cd /usr/realtime*/testsuite/kern/latency; ./run
\layout Standard

and then you should see something like this:
\layout LyX-Code

ubuntu:/usr/realtime-2.6.12-magma/testsuite/kern/latency$ ./run 
\layout LyX-Code

* 
\layout LyX-Code

* 
\layout LyX-Code

* Type ^C to stop this application.
 
\layout LyX-Code

* 
\layout LyX-Code

*
\layout LyX-Code

\layout LyX-Code

## RTAI latency calibration tool ## 
\layout LyX-Code

# period = 100000 (ns) 
\layout LyX-Code

# avrgtime = 1 (s) 
\layout LyX-Code

# do not use the FPU 
\layout LyX-Code

# start the timer 
\layout LyX-Code

# timer_mode is oneshot
\layout LyX-Code

\layout LyX-Code

RTAI Testsuite - KERNEL latency (all data in nanoseconds) 
\layout LyX-Code

RTH| lat min| ovl min| lat avg| lat max| ovl max| overruns 
\layout LyX-Code

RTD|   -1571|   -1571|    1622|    8446|    8446|      0 
\layout LyX-Code

RTD|   -1558|   -1571|    1607|    7704|    8446|      0 
\layout LyX-Code

RTD|   -1568|   -1571|    1640|    7359|    8446|      0 
\layout LyX-Code

RTD|   -1568|   -1571|    1653|    7594|    8446|      0 
\layout LyX-Code

RTD|   -1568|   -1571|    1640|   10636|   10636|      0 
\layout LyX-Code

RTD|   -1568|   -1571|    1640|   10636|   10636|      0
\layout Standard

While the test is running, you should "abuse" the computer.
 Move windows around on the screen.
 Surf the web.
 Copy some large files around on the disk.
 Play some music.
 Run an OpenGL program such as glxgears.
 The idea is to put the PC through its paces while the latency test checks
 to see what the worst case numbers are.
\layout Standard

The last number in the column labeled "ovl max" is the most important.
 Write it down - you will need it later.
 It contains the worst latency measurement during the entire run of the
 test.
 In the example above, that is 10636 nano-seconds, or 10.6 micro-seconds,
 which is excellent.
 However the example only ran for a few seconds (it prints one line every
 second).
 You should run the test for at least several minutes; sometimes the worst
 case latency doesn't happen very often, or only happens when you do some
 particular action.
 I had one Intel motherboard that worked pretty well most of the time, but
 every 64 seconds it had a very bad 300uS latency.
 Fortunately that is fixable, see FixingDapperSMIIssues in the wiki found
 at wiki.linuxcnc.org.
\layout Standard

So, what do the results mean? If your "ovl max" number is less than about
 15-20 microseconds (15000-20000 nanoseconds), the computer should give
 very nice results with software stepping.
 If the max latency is more like 30-50 microseconds, you can still get good
 results, but your maximum step rate might be a little dissapointing, especially
 if you use microstepping or have very fine pitch leadscrews.
 If the numbers are 100uS or more (100,000 nanoseconds), then the PC is
 not a good candidate for software stepping.
 Numbers over 1 millisecond (1,000,000 nanoseconds) mean the PC is not a
 good candidate for EMC, regardless of whether you use software stepping
 or not.
\layout Standard

Note that if you get high numbers, there may be ways to improve them.
 For example, one PC had very bad latency (several milliseconds) when using
 the onboard video.
 But a $5 used Matrox video card solved the problem - EMC does not require
 bleeding edge hardware.
 
\layout Subsubsection

Figure out what your drives expect
\layout Standard

Different brands of stepper drives have different timing requirements on
 their step and direction inputs.
 So you need to dig out (or Google for) the data sheet that has your drive's
 specs.
\layout Quotation

For example, the Gecko G202 manual says this:
\layout Quotation

Step Frequency: 0 to 200 kHz 
\layout Quotation

Step Pulse 
\begin_inset Quotes eld
\end_inset 

0
\begin_inset Quotes erd
\end_inset 

 Time: 0.5 uS min (Step on falling edge) 
\layout Quotation

Step Pulse 
\begin_inset Quotes eld
\end_inset 

1
\begin_inset Quotes erd
\end_inset 

 Time: 4.5 uS min 
\layout Quotation

Direction Setup: 1 uS min (20 uS min hold time after Step edge)
\layout Quotation

\SpecialChar ~

\layout Quotation

The Gecko G203V specifications are:
\layout Quotation

Step Frequency: 0 to 333 kHz 
\layout Quotation

Step Pulse 
\begin_inset Quotes eld
\end_inset 

0
\begin_inset Quotes erd
\end_inset 

 Time: 2.0 uS min (Step on rising edge) 
\layout Quotation

Step Pulse 
\begin_inset Quotes eld
\end_inset 

1
\begin_inset Quotes erd
\end_inset 

 Time: 1.0 uS min 
\layout Quotation

Direction Setup: 
\begin_deeper 
\layout Quotation

200 nS (0.2uS) before step pulse rising edge 
\layout Quotation

200 nS (0.2uS) hold after step pulse rising edge
\end_deeper 
\layout Standard

A Xylotex drive datasheet has a nice drawing of the timing requirements,
 which are:
\layout Quotation

Minimum DIR setup time before rising edge of STEP Pulse 200nS Minimum 
\layout Quotation

DIR hold time after rising edge of STEP pulse 200nS 
\layout Quotation

Minimum STEP pulse high time 2.0uS 
\layout Quotation

Minimum STEP pulse low time 1.0uS 
\layout Quotation

Step happens on rising edge
\layout Standard

Once you find the numbers, write them down too - you need them in the next
 step.
\layout Subsubsection

Choose your BASE_PERIOD
\layout Standard

BASE_PERIOD is the "heartbeat" of your EMC computer.
 Every period, the software step generator decides if it is time for another
 step pulse.
 A shorter period will allow you to generate more pulses per second, within
 limits.
 But if you go too short, your computer will spend so much time generating
 step pulses that everything else will slow to a crawl, or maybe even lock
 up.
 Latency and stepper drive requirements affect the shortest period you can
 use, as we will see in a minute.
\layout Standard

Let's look at the Gecko example first.
 The G202 can handle step pulses that go low for 0.5uS and high for 4.5uS,
 it needs the direction pin to be stable 1uS before the falling edge, and
 remain stable for 20uS after the falling edge.
 The longest timing requirement is the 20uS hold time.
 A simple approach would be to set the period at 20uS.
 That means that all changes on the STEP and DIR lines are separated by
 20uS.
 All is good, right?
\layout Standard

Wrong! If there was ZERO latency, then all edges would be separated by 20uS,
 and everything would be fine.
 But all computers have some latency.
 Latency means lateness.
 If the computer has 11uS of latency, that means sometimes the software
 runs as much as 11uS later than it was supposed to.
 If one run of the software is 11uS late, and the next one is on time, the
 delay from the first to the second is only 9uS.
 If the first one generated a step pulse, and the second one changed the
 direction bit, you just violated the 20uS G202 hold time requirement.
 That means your drive might have taken a step in the wrong direction, and
 your part will be the wrong size.
\layout Standard

The really nasty part about this problem is that it can be very very rare.
 Worst case latencies might only happen a few times a minute, and the odds
 of bad latency happening just as the motor is changing direction are low.
 So you get very rare errors that ruin a part every once in a while and
 are impossible to troubleshoot.
\layout Standard

The simplest way to avoid this problem is to choose a BASE_PERIOD that is
 the sum of the longest timing requirement of your drive, and the worst
 case latency of your computer.
 If you are running a Gecko with a 20uS hold time requirement, and your
 latency test said you have a maximum latency of 11uS, then if you set the
 BASE_PERIOD to 20+11 = 31uS (31000 nano-seconds in the ini file), you are
 guaranteed to meet the drive's timing requirements.
\layout Standard

But there is a tradeoff.
 Making a step pulse requires at least two periods.
 One to start the pulse, and one to end it.
 Since the period is 31uS, it takes 2x31 = 62uS to create a step pulse.
 That means the maximum step rate is only 16,129 steps per second.
 Not so good.
 (But don't give up yet, we still have some tweaking to do in the next section.)
\layout Standard

For the Xylotex, the setup and hold times are very short, 200nS each (0.2uS).
 The longest time is the 2uS high time.
 If you have 11uS latency, then you can set the BASE_PERIOD as low as 11+2=13uS.
 Getting rid of the long 20uS hold time really helps! With a period of 13uS,
 a complete step takes 2x13 = 26uS, and the maximum step rate is 38,461
 steps per second!
\layout Standard

But you can't start celebrating yet.
 Note that 13uS is a very short period.
 If you try to run the step generator every 13uS, there might not be enough
 time left to run anything else, and your computer will lock up.
 If you are aiming for periods of less than 25uS, you should start at 25uS
 or more, run EMC, and see how things respond.
 If all is well, you can gradually decrease the period.
 If the mouse pointer starts getting sluggish, and everything else on the
 PC slows down, your period is a little too short.
 Go back to the previous value that let the computer run smoothly.
\layout Standard

In this case, sppose you started at 25uS, trying to get to 13uS, but you
 find that around 16uS is the limit - any less and the computer doesn't
 respond very well.
 So you use 16uS.
 With a 16uS period and 11uS latency, the shortest output time will be 16-11
 = 5uS.
 The drive only needs 2uS, so you have some margin.
 Margin is good - you don't want to lose steps because you cut the timing
 too close.
\layout Standard

What is the maximum step rate? Remember, two periods to make a step.
 You settled on 16uS for the period, so a step takes 32uS.
 That works out to a not bad 31,250 steps per second.
\layout Subsubsection

Use steplen, stepspace, dirsetup, and/or dirhold
\layout Standard

In the last section, we got the Xylotex drive to a 16uS period and a 31,250
 step per second maximum speed.
 But the Gecko was stuck at 31uS and a not-so-nice 16,129 steps per second.
 The Xylotex example is as good as we can make it.
 But the Gecko can be improved.
\layout Standard

The problem with the G202 is the 20uS hold time requirement.
 That plus the 11uS latency is what forces us to use a slow 31uS period.
 But the EMC2 software step generator has some parameters that let you increase
 the various time from one period to several.
 For example, if steplen is changed from 1 to 2, then it there will be two
 periods between the beginning and end of the step pulse.
 Likewise, if dirhold is changed from 1 to 3, there will be at least three
 periods between the step pulse and a change of the direction pin.
\layout Standard

If we can use dirhold to meet the 20uS hold time requirement, then the next
 longest time is the 4.5uS high time.
 Add the 11uS latency to the 4.5uS high time, and you get a minimum period
 of 15.5uS.
 When you try 15.5uS, you find that the computer is sluggish, so you settle
 on 16uS.
 If we leave dirhold at 1 (the default), then the minimum time between step
 and direction is the 16uS period minus the 11uS latency = 5uS, which is
 not enough.
 We need another 15uS.
 Since the period is 16uS, we need one more period.
 So we change dirhold from 1 to 2.
 Now the minimum time from the end of the step pulse to the changing direction
 pin is 5+16=21uS, and we don't have to worry about the Gecko stepping the
 wrong direction because of latency.
\layout Standard

If the computer has a latency of 11uS, then a combination of a 16uS base
 period, and a dirhold value of 2 ensures that we will always meet the timing
 requirements of the Gecko.
 For normal stepping (no direction change), the increased dirhold value
 has no effect.
 It takes two periods totalling 32uS to make each step, and we have the
 same 31,250 step per second rate that we got with the Xylotex.
\layout Standard

The 11uS latency number used in this example is very good.
 If you work through these examples with larger latency, like 20 or 25uS,
 the top step rate for both the Xylotex and the Gecko will be lower.
 But the same formulas apply for calculating the optimum BASE_PERIOD, and
 for tweaking dirhold or other step generator parameters.
\layout Subsubsection

No Guessing!
\layout Standard

For a fast AND reliable software based stepper system, you cannot just guess
 at periods and other configuration paremeters.
 You need to make measurements on your computer, and do the math to ensure
 that your drives get the signals they need.
\layout Standard

To make the math easier, I've created an Open Office spreadsheet (http://wiki.lin
uxcnc.org/uploads/StepTimingCalculator.ods).
 You enter your latency test result and your stepper drive timing requirements
 and the spreadsheet calculates the optimum BASE_PERIOD.
 Next, you test the period to make sure it won't slow down or lock up your
 PC.
 Finally, you enter the actual period, and the spreadsheet will tell you
 the stepgen parameter settings that are needed to meet your drive's timing
 requirements.
 It also calculates the maximum step rate that you will be able to generate.
\layout Standard

I've added a few things to the spreadsheet to calculate max speed and stepper
 electrical calculations.
 
\the_end
